import ast
import sys

class HelixCompiler(ast.NodeVisitor):
    def __init__(self):
        self.assembly = []
        self.data_section = []
        self.label_counter = 0
        self.scope = {} # Name -> {type, offset/addr}
        self.stack_pointer = 0 # Relative to FP
        self.dat_ptr = 8192 # Start of .DAT section (0x2000)
        self.global_inits = [] # List of (name, addr, size, val)
    def emit(self, instruction):
        self.assembly.append(instruction)
        
    def new_label(self, specific=None):
        self.label_counter += 1
        return f"L_{specific or 'blk'}_{self.label_counter}"

    def compile(self, source_code):
        self.assembly = [
            "; Generated by Helix Python Compiler",
            ".ORG 0x0000",
            "LDI.W SP, 0x6000 ; Initialize Stack",
            "CALL __init_globals", 
            "CALL main",
            "HLT"
        ]
        
        # Main Body Wrapper
        self.emit("; --- Main ---")
        self.emit("main:")
        # Prologue for Main (FP Setup)
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W FP, [SP, 0]")
        self.emit("MOV.W FP, SP")
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R14, [SP, 0]") 
        
        # Initialize stack pointer for Main (LR is at FP-1)
        self.stack_pointer = -1
        
        # Compile Source (Collects globals instructions and inits)
        tree = ast.parse(source_code)
        self.visit(tree)
        
        # Epilogue for Main
        self.emit("MOV.W SP, FP")
        self.emit("ADD.W SP, SP, -1")
        self.emit("LD.W R14, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        self.emit("LD.W FP, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        self.emit("RET")
        
        # Emit Helpers and Globals (After collection)
        self.emit_global_inits() 
        self.emit_print_int_function()
        
        # Emit Data Section
        if self.data_section:
            self.assembly.append("\n; --- Data Section ---")
            self.assembly.append(".DAT")
            self.assembly.extend(self.data_section)
            
        return "\n".join(self.assembly)

    def visit_FunctionDef(self, node):
        func_label = node.name
        self.emit(f"\n; Function: {func_label}")
        self.emit(f"{func_label}:")
        
        # Save previous scope/stack state
        prev_scope = self.scope.copy()
        prev_sp = self.stack_pointer
        
        # Reset for new function, but keep Globals (Matrices)
        # Integers on stack are not accessible via standard FP offsets easily in this simple compiler
        # unless we support 'non-local' lookups or absolute formatting.
        # For now, just copy 'matrix' types.
        self.scope = {k: v for k, v in prev_scope.items() if v.get('type') == 'matrix'}
        self.stack_pointer = -1 # Account for LR saved at FP-1
        
        # Prologue (Save Frame)
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W FP, [SP, 0]")
        self.emit("MOV.W FP, SP")
        
        # Save LR (R14)
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R14, [SP, 0]")
        
        num_args = len(node.args.args)
        for i, arg in enumerate(node.args.args):
            # Args are at FP + 1 + (num_args - 1 - i)
            # ArgN is at FP + 1
            offset = 1 + (num_args - 1 - i)
            self.scope[arg.arg] = {'offset': offset, 'type': 'int'}
        
        # Body
        for stmt in node.body:
            self.visit(stmt)
            
        # Epilogue
        self.emit("MOV.W SP, FP")
        self.emit("ADD.W SP, SP, -1") # Restore LR
        self.emit("LD.W R14, [SP, 0]")
        self.emit("ADD.W SP, SP, 1") # Restore FP
        self.emit("LD.W FP, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        self.emit("RET")
        
        # Restore previous scope
        self.scope = prev_scope
        self.stack_pointer = prev_sp

    def visit_Return(self, node):
        if node.value:
            self.visit(node.value)
        self.emit("MOV.W SP, FP")
        self.emit("ADD.W SP, SP, -1")
        self.emit("LD.W R14, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        self.emit("LD.W FP, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        self.emit("RET")

    def visit_AnnAssign(self, node):
        target = node.target
        if not isinstance(target, ast.Name):
            raise NotImplementedError("Only annotated assignment to variables supported")
            
        var_name = target.id
        
        # Check if it is a Matrix declaration
        is_matrix = False
        rows = 0
        cols = 0
        
        ann = node.annotation
        if isinstance(ann, ast.Subscript):
            if isinstance(ann.value, ast.Name) and ann.value.id == "Matrix":
                is_matrix = True
                dims = ann.slice
                # Handle Python < 3.9 ast.Index wrapper
                if isinstance(dims, ast.Index):
                    dims = dims.value
                
                if isinstance(dims, ast.Tuple):
                    elts = dims.elts
                    
                    # Helper to extract value
                    def get_val(n):
                        if isinstance(n, ast.Constant): return n.value
                        if isinstance(n, ast.Num): return n.n
                        return None

                    if len(elts) == 2:
                        rows = get_val(elts[0])
                        cols = get_val(elts[1])
                        depth = 1 # Default 2D
                    elif len(elts) == 3:
                        depth = get_val(elts[0])
                        rows = get_val(elts[1])
                        cols = get_val(elts[2])
                        
        if is_matrix and rows is not None and cols is not None:
             # Allocate in .DAT
             # Size = Depth * Rows * Cols
             depth = depth if 'depth' in locals() else 1
             size = depth * rows * cols
             addr = self.dat_ptr
             self.dat_ptr += size
             
             self.scope[var_name] = {
                 'type': 'matrix',
                 'addr': addr,
                 'dims': (depth, rows, cols)
             }
             if depth > 1:
                 self.emit(f"; Declared 3D Matrix {var_name} [{depth}x{rows}x{cols}] at .DAT {addr}")
             else:
                 self.emit(f"; Declared Matrix {var_name} [{rows}x{cols}] at .DAT {addr}")
             

             
             # Initialization Logic
             init_vals = []
             
             if node.value:
                 # Case 1: fill(value)
                 if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id == 'fill':
                     val = None
                     if len(node.value.args) == 1 and isinstance(node.value.args[0], ast.Constant):
                         val = node.value.args[0].value
                     elif len(node.value.keywords) > 0:
                         for kw in node.value.keywords:
                             if kw.arg == 'val' or kw.arg == 'value':
                                 if isinstance(kw.value, ast.Constant):
                                     val = kw.value.value
                     
                     if val is not None:
                         init_vals = [val] * (rows * cols)
                         self.emit(f"; fill({val}) detected. init_vals len: {len(init_vals)}")
                     else:
                         self.emit("; fill() called but value not constant/found")

                 # Case 1b: Matrix(rows, cols, fill=val)
                 elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id == 'Matrix':
                     val = 0
                     for kw in node.value.keywords:
                         if kw.arg == 'fill' and isinstance(kw.value, ast.Constant):
                             val = kw.value.value
                     
                     if val != 0:
                         init_vals = [val] * (rows * cols)
                         self.emit(f"; Matrix(fill={val}) detected. init_vals len: {len(init_vals)}")
                     else:
                         # Default 0 is fine, but we might want to be explicit?
                         # If init_vals is empty, it falls through to "Init value ignored".
                         # We should probably init 0 if it's a Matrix call?
                         # For now, only explicit fill.
                         pass
                         
                 # Case 2: Literal List [(1,2), (3,4)]
                 elif isinstance(node.value, ast.List):
                     # Flatten
                     for row_node in node.value.elts:
                         if isinstance(row_node, (ast.Tuple, ast.List)):
                             for col_node in row_node.elts:
                                 if isinstance(col_node, ast.Constant):
                                     init_vals.append(col_node.value)
                                 else:
                                     # Default 0 if complex
                                     init_vals.append(0)
                         else:
                             # 1D List? Treat as row-major
                             if isinstance(row_node, ast.Constant):
                                 init_vals.append(row_node.value)
             
             if init_vals:
                 # Buffer to global_inits
                 # We need to change global_inits structure to support list of values, 
                 # or just append multiple entries?
                 # Current structure: (name, addr, size, val) -> fills 'val' 'size' times.
                 # If we have distinct values, we can't use 'val'.
                 # Let's emit code directly here?
                 # No, this might be inside a function but matrices are global (.DAT).
                 # We must use __init_globals or emit stores relative to R0 (0) or LDI addr.
                 
                 # Hack: Add a new type of init to global_inits?
                 # Or just use the existing one for 'fill' and add 'data' support.
                 self.global_inits.append({
                     'type': 'matrix_data',
                     'addr': addr,
                     'data': init_vals
                 })
             else:
                  self.emit(f"; Init value ignored/unknown for {var_name}")

    def emit_global_inits(self):
        self.emit("; --- Global Initialization ---")
        self.emit("__init_globals:")
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R14, [SP, 0]")
        
        if self.global_inits:
            for item in self.global_inits:
                if isinstance(item, dict) and item.get('type') == 'matrix_data':
                    # Explicit Data List
                    addr = item['addr']
                    data = item['data']
                    self.emit(f"; Init Matrix Data at {addr} (Len={len(data)})")
                    
                    # R6 = Base Pointer
                    self.emit(f"LDI.W R6, {addr}")
                    
                    for i, val in enumerate(data):
                        self.emit(f"LDI.W R1, {val}")
                        self.emit("ST.W R1, [R6, 0]")
                        
                        # Increment Pointer if more data
                        if i < len(data) - 1:
                            self.emit("LDI.W R2, 1")
                            self.emit("ADD.W R6, R6, R2")
                            
                else:
                     # Default Tuple (name, addr, size, val)
                     name, addr, size, val = item
                     self.emit(f"; Init {name} with fill={val}")
                     lbl_init = self.new_label(f"init_{name}")
                     lbl_end = self.new_label(f"init_{name}_end")
                     
                     self.emit("LDI.W R3, 0")
                     self.emit(f"{lbl_init}:")
                     self.emit(f"LDI.W R1, {size}")
                     self.emit("CMP.W R3, R1")
                     self.emit(f"BEQ {lbl_end}")
                     self.emit(f"LDI.W R4, {addr}")
                     self.emit("ADD.W R4, R4, R3")
                     self.emit(f"LDI.W R1, {val}") # R1 = Fill Value
                     self.emit("ST.W R1, [R4, 0]")
                     
                     # Increment Loop
                     self.emit("LDI.W R2, 1") # Use R2 for increment, R1 might be clobbered
                     self.emit("ADD.W R3, R3, R2")
                     self.emit(f"JMP {lbl_init}")
                     self.emit(f"{lbl_end}:")
             
        self.emit("LD.W R14, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        self.emit("RET")

    def emit_print_int_function(self):
        self.emit("; --- Helper: Print Integer (R1) ---")
        self.emit("__print_int:")
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R14, [SP, 0]") # Save LR
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R4, [SP, 0]")  # Save R4
        
        # Check for 0
        self.emit("CMP.W R1, 0")
        lbl_check_neg = self.new_label("check_neg")
        self.emit(f"BNE {lbl_check_neg}")
        self.emit("LDI.W R2, 16384")
        self.emit("ADD.W R2, R2, R2") # R2 = 32768
        self.emit("LDI.W R1, 48") # '0'
        self.emit("ST.W R1, [R2, 0]")
        lbl_ret = self.new_label("print_int_ret")
        self.emit(f"JMP {lbl_ret}")
        
        # Check Negative
        self.emit(f"{lbl_check_neg}:")
        self.emit("LDI.W R2, 0")
        self.emit("CMP.W R1, R2")
        lbl_print_pos = self.new_label("print_pos")
        self.emit(f"BGT {lbl_print_pos}")
        
        # Print '-'
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R1, [SP, 0]") # Push R1
        
        self.emit("LDI.W R2, 16384")
        self.emit("ADD.W R2, R2, R2")
        self.emit("LDI.W R1, 45") # '-'
        self.emit("ST.W R1, [R2, 0]")
        
        self.emit("LD.W R1, [SP, 0]") # Pop R1
        self.emit("ADD.W SP, SP, 1")
        
        # Negate R1
        self.emit("LDI.W R2, -1")
        self.emit("MUL.W R1, R1, R2")
        
        self.emit(f"{lbl_print_pos}:")
        
        # Modulo Loop
        # R4 = Digit Count
        self.emit("LDI.W R4, 0")
        
        lbl_mod_loop = self.new_label("print_int_mod")
        self.emit(f"{lbl_mod_loop}:")
        
        # Digit = R1 % 10
        self.emit("MOV.W R3, R1")
        self.emit("LDI.W R2, 10")
        self.emit("MOD.W R3, R3, R2") 
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R3, [SP, 0]") # Push Digit
        
        self.emit("LDI.W R2, 1")
        self.emit("ADD.W R4, R4, R2") # Count++
        
        # R1 = R1 / 10
        self.emit("LDI.W R2, 10")
        self.emit("DIV.W R1, R1, R2")
        
        self.emit("CMP.W R1, 0")
        self.emit(f"BNE {lbl_mod_loop}")
        
        # Print Loop
        lbl_print_loop = self.new_label("print_int_out")
        self.emit(f"{lbl_print_loop}:")
        
        self.emit("LD.W R1, [SP, 0]") # Pop Digit
        self.emit("ADD.W SP, SP, 1")
        
        self.emit("LDI.W R2, 48") 
        self.emit("ADD.W R1, R1, R2") # + '0'
        
        self.emit("LDI.W R2, 16384")
        self.emit("ADD.W R2, R2, R2") # UART
        self.emit("ST.W R1, [R2, 0]")
        
        self.emit("LDI.W R2, -1")
        self.emit("ADD.W R4, R4, R2")
        self.emit("CMP.W R4, 0")
        self.emit(f"BNE {lbl_print_loop}")
        
        self.emit(f"{lbl_ret}:")
        # Newline REMOVED from helper to allow inline printing
        # Caller must handle newline if needed.

        
        self.emit("LD.W R4, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        self.emit("LD.W R14, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        self.emit("RET")

    def visit_Import(self, node):
        # Ignore imports in ASM generation
        for alias in node.names:
            self.emit(f"; Import {alias.name}")
            
    def visit_ImportFrom(self, node):
        # Ignore imports in ASM generation
        self.emit(f"; From {node.module} Import ...")

    print_label_counter = 0
    
    def visit_Expr(self, node):
        # Handle standalone expressions (like print)
        # Check if it's a call
        if isinstance(node.value, ast.Call):
            func = node.value.func
            if isinstance(func, ast.Name) and func.id == "print":
                 # Implementation of print(arg)
                 # Only support single string constant for now
                 if len(node.value.args) == 1 and isinstance(node.value.args[0], ast.Constant):
                     val = node.value.args[0].value
                     if isinstance(val, str):
                         self.emit(f"; PRINT '{val}'")
                         # Construct UART Address 0x8000 (32768)
                         # 16384 + 16384
                         self.emit("LDI.W R2, 16384")
                         self.emit("ADD.W R2, R2, R2") # R2 = 32768
                         
                         # Emit chars
                         for char in val:
                             code = ord(char)
                             self.emit(f"LDI.W R1, {code} ; '{char}'")
                             self.emit("ST.W R1, [R2, 0]")
                         
                         # Emit Newline
                         self.emit("LDI.W R1, 10")
                         self.emit("ST.W R1, [R2, 0]")
                         return

                 # Support print(int_const)
                 if len(node.value.args) == 1 and isinstance(node.value.args[0], ast.Constant):
                      val = node.value.args[0].value
                      if isinstance(val, int):
                          self.emit(f"LDI.W R1, {val}")
                          self.emit("CALL __print_int")
                          # Emit Newline
                          self.emit("LDI.W R2, 16384")
                          self.emit("ADD.W R2, R2, R2")
                          self.emit("LDI.W R1, 10")
                          self.emit("ST.W R1, [R2, 0]")
                          return

                 # Support print(-int_const)
                 if len(node.value.args) == 1 and isinstance(node.value.args[0], ast.UnaryOp):
                      uop = node.value.args[0]
                      if isinstance(uop.op, ast.USub) and isinstance(uop.operand, ast.Constant):
                           val = uop.operand.value
                           if isinstance(val, int):
                               self.emit(f"LDI.W R1, -{val}")
                               self.emit("CALL __print_int")
                               # Emit Newline
                               self.emit("LDI.W R2, 16384")
                               self.emit("ADD.W R2, R2, R2")
                               self.emit("LDI.W R1, 10")
                               self.emit("ST.W R1, [R2, 0]")
                               return

                 # Support print(var) - Assume Int for now
                 if len(node.value.args) == 1 and isinstance(node.value.args[0], ast.Name):
                      var_name = node.value.args[0].id
                      if var_name in self.scope:
                          var_info = self.scope[var_name]
                          if var_info['type'] == 'int':
                              offset = var_info['offset']
                              self.emit(f"LD.W R1, [FP, {offset}]")
                              self.emit("CALL __print_int")
                              # Emit Newline
                              self.emit("LDI.W R2, 16384")
                              self.emit("ADD.W R2, R2, R2")
                              self.emit("LDI.W R1, 10")
                              self.emit("ST.W R1, [R2, 0]")
                              return
                          elif var_info['type'] == 'matrix':
                              # Matrix Printing
                              # Loop rows (R3), cols (R4)
                              rows, cols = var_info['dims']
                              addr = var_info['addr']
                              
                              self.emit(f"; Print Matrix {var_name} [{rows}x{cols}]")
                              
                              # R3 = Row Index
                              self.emit("LDI.W R3, 0")
                              lbl_row_start = self.new_label("print_row")
                              lbl_row_end = self.new_label("print_row_end")
                              
                              self.emit(f"{lbl_row_start}:")
                              self.emit(f"LDI.W R1, {rows}")
                              self.emit("CMP.W R3, R1")
                              self.emit(f"BEQ {lbl_row_end}")
                              
                              # Print '[ '
                              self.emit("LDI.W R2, 16384")
                              self.emit("ADD.W R2, R2, R2") 
                              self.emit("LDI.W R1, 91") # '['
                              self.emit("ST.W R1, [R2, 0]")
                              self.emit("LDI.W R1, 32") # ' '
                              self.emit("ST.W R1, [R2, 0]")
                              
                              # R4 = Col Index
                              self.emit("LDI.W R4, 0")
                              lbl_col_start = self.new_label("print_col")
                              lbl_col_end = self.new_label("print_col_end")
                              
                              self.emit(f"{lbl_col_start}:")
                              self.emit(f"LDI.W R1, {cols}")
                              self.emit("CMP.W R4, R1")
                              self.emit(f"BEQ {lbl_col_end}")
                              
                              # Calc Address: addr + i*cols + j
                              # i*cols
                              self.emit("MOV.W R5, R3")
                              self.emit(f"LDI.W R1, {cols}")
                              self.emit("MUL.W R5, R5, R1")
                              # + j
                              self.emit("ADD.W R5, R5, R4")
                              # + base
                              self.emit(f"LDI.W R6, {addr}")
                              self.emit("ADD.W R6, R6, R5")
                              
                              # Load Element
                              self.emit("LD.W R1, [R6, 0]")
                              
                              # Save R3 (Row Index) as __print_int clobbers it
                              self.emit("ADD.W SP, SP, -1")
                              self.emit("ST.W R3, [SP, 0]")
                              
                              # Print Int
                              self.emit("CALL __print_int")
                              
                              # Restore R3
                              self.emit("LD.W R3, [SP, 0]")
                              self.emit("ADD.W SP, SP, 1")
                              
                              # Print Space ' '
                              self.emit("LDI.W R2, 16384")
                              self.emit("ADD.W R2, R2, R2") 
                              self.emit("LDI.W R1, 32")
                              self.emit("ST.W R1, [R2, 0]")
                              
                              # j++
                              self.emit("LDI.W R1, 1")
                              self.emit("ADD.W R4, R4, R1")
                              self.emit(f"JMP {lbl_col_start}")
                              self.emit(f"{lbl_col_end}:")
                              
                              # Print ']'
                              self.emit("LDI.W R2, 16384")
                              self.emit("ADD.W R2, R2, R2") 
                              self.emit("LDI.W R1, 93") # ']'
                              self.emit("ST.W R1, [R2, 0]")
                              
                              # Print Newline '\n'
                              self.emit("LDI.W R1, 10")
                              self.emit("ST.W R1, [R2, 0]")
                              
                              # i++
                              self.emit("LDI.W R1, 1")
                              self.emit("ADD.W R3, R3, R1")
                              self.emit(f"JMP {lbl_row_start}")
                              self.emit(f"{lbl_row_end}:")
                              return

                          
                 # Support print(A[i,j])
                 if len(node.value.args) == 1 and isinstance(node.value.args[0], ast.Subscript):
                      # visit_Subscript puts value in R1 (Load context implied)
                      self.visit(node.value.args[0])
                      self.emit("CALL __print_int")
                      # Emit Newline
                      self.emit("LDI.W R2, 16384")
                      self.emit("ADD.W R2, R2, R2")
                      self.emit("LDI.W R1, 10")
                      self.emit("ST.W R1, [R2, 0]")
                      return

                 self.emit("; PRINT statement (Complex/Unsupported args ignored in V0.2)")
                 return
        self.visit(node.value)



    def visit_Subscript(self, node):
        # Handle M[i, j]
        # Only support Matrix load/store for now.
        if isinstance(node.value, ast.Name):
            var_name = node.value.id
            if var_name in self.scope:
                var_info = self.scope[var_name]
                if var_info['type'] == 'matrix':
                    dims = var_info['dims']
                    if len(dims) == 2:
                        rows, cols = dims
                        depth = 1
                    else:
                        depth, rows, cols = dims
                        
                    base_addr = var_info['addr']
                    
                    # Parse Indices [i, j]
                    # Python 3.9+: node.slice is the Index/Tuple directly.
                    # Python <3.9: node.slice.value is the Index/Tuple.
                    # We assume 3.9+ AST structure or standard Tuple.
                    
                    indices = []
                    if isinstance(node.slice, ast.Tuple):
                        indices = node.slice.elts
                    elif isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.Tuple):
                         indices = node.slice.value.elts # Old AST
                    else:
                        raise NotImplementedError("Matrix access requires [i, j] tuple index")
                        
                    if len(indices) == 2:
                        # 2D Access: [row, col] -> (row * cols) + col
                        # Check definition
                        if len(var_info['dims']) == 3 and var_info['dims'][0] > 1:
                             # Accessing 3D matrix with 2 indices? 
                             # For now, strictly enforce dimension match or assume Depth=0?
                             # Let's enforce match.
                             raise ValueError(f"Matrix {var_name} is 3D, but accessed with 2 indices")

                        cols = var_info['dims'][2] # (1, rows, cols) or (depth, rows, cols) -> wait, stored as (rows, cols) before?
                        # Fix: Previous code stored (rows, cols). New code stores (depth, rows, cols).
                        # We need to handle backward compatibility of definitions if we changed the storage format.
                        # Logic: if len(dims)==2 -> (rows, cols). If len(dims)==3 -> (depth, rows, cols).
                        
                        current_dims = var_info['dims']
                        if len(current_dims) == 2:
                            r_cnt = current_dims[0]
                            c_cnt = current_dims[1]
                        else:
                             # Should not happen if we enforce match, but for safety
                             c_cnt = current_dims[2]

                        # 1. Row -> R1
                        self.visit(indices[0])
                        self.emit("ADD.W SP, SP, -1")
                        self.emit("ST.W R1, [SP, 0]")
                        
                        # 2. Col -> R1 -> R4
                        self.visit(indices[1])
                        self.emit("MOV.W R4, R1")
                        
                        # 3. Pop Row -> R3
                        self.emit("LD.W R3, [SP, 0]")
                        self.emit("ADD.W SP, SP, 1")
                        
                        # 4. Calc Offset: R3 * c_cnt + R4
                        self.emit("MOV.W R5, R3")
                        self.emit(f"LDI.W R2, {c_cnt}")
                        self.emit("MUL.W R5, R5, R2")
                        self.emit("ADD.W R5, R5, R4")
                        
                    elif len(indices) == 3:
                        # 3D Access: [d, r, c] -> d*(rows*cols) + r*cols + c
                        if len(var_info['dims']) != 3:
                            raise ValueError(f"Matrix {var_name} is not 3D")
                            
                        depth_cnt, row_cnt, col_cnt = var_info['dims']
                        
                        # 1. Depth -> R1
                        self.visit(indices[0])
                        self.emit("ADD.W SP, SP, -1")
                        self.emit("ST.W R1, [SP, 0]") # Push d
                        
                        # 2. Row -> R1
                        self.visit(indices[1])
                        self.emit("ADD.W SP, SP, -1")
                        self.emit("ST.W R1, [SP, 0]") # Push r

                        # 3. Col -> R1 (Keep in R1/R4)
                        self.visit(indices[2])
                        self.emit("MOV.W R4, R1") # c in R4
                        
                        # Pop r -> R3
                        self.emit("LD.W R3, [SP, 0]")
                        self.emit("ADD.W SP, SP, 1")
                        
                        # Pop d -> R5
                        self.emit("LD.W R5, [SP, 0]")
                        self.emit("ADD.W SP, SP, 1")
                        
                        # Calculate Offset
                        # Offset = d * (rows*cols) + r * cols + c
                        
                        # Term 1: d * (rows*cols)
                        plane_size = row_cnt * col_cnt
                        self.emit(f"LDI.W R2, {plane_size}")
                        self.emit("MUL.W R5, R5, R2") # R5 = d * plane_size
                        
                        # Term 2: r * cols
                        self.emit("MOV.W R2, R3") # R2 = r
                        self.emit(f"LDI.W R1, {col_cnt}")
                        self.emit("MUL.W R2, R2, R1") # R2 = r * cols
                        
                        # Sum: R5 + R2 + R4(c)
                        self.emit("ADD.W R5, R5, R2")
                        self.emit("ADD.W R5, R5, R4")
                        
                    else:
                        raise ValueError("Matrix access requires 2 or 3 indices")

                    # 5. Add Base Address
                    self.emit(f"LDI.W R6, {base_addr}")
                    self.emit("ADD.W R6, R6, R5")
                    
                    # Context: Load or Store?
                    # node.ctx is Load, Store, or Del
                    if isinstance(node.ctx, ast.Load):
                        self.emit("LD.W R1, [R6, 0]")
                        return
                    elif isinstance(node.ctx, ast.Store):
                        # For Store, we leave the Address in R6.
                        # visit_Assign handles the actual Store instruction using the value on Stack/R1.
                        return
        
        raise NotImplementedError(f"Subscript not implemented for {type(node.value)}")

    def visit_BinOp(self, node):
        # Recursively visit Left and Right
        self.visit(node.left)
        # R1 has result/address of Left
        # Inspect types? AST doesn't have types attached unless we track them.
        # But visit() doesn't return type info.
        # We need a way to know the type of the expression on stack.
        # Hack: For v0.1, we assume if it's a Name, we look up type.
        # If it's a BinOp result, we need to know its type.
        # We can push type info to a parallel stack in compiler?
        # Or just rely on R1.
        
        # Simpler: For MatMult, operands MUST be variables (Names) in this version.
        if isinstance(node.op, ast.MatMult):
            if not isinstance(node.left, ast.Name) or not isinstance(node.right, ast.Name):
                raise NotImplementedError("MatMult only supported on variables for now")
            
            name_a = node.left.id
            name_b = node.right.id
            
            info_a = self.scope[name_a]
            info_b = self.scope[name_b]
            
            if info_a['type'] != 'matrix' or info_b['type'] != 'matrix':
                 raise TypeError("MatMult operands must be matrices")
                 
            # Emitting MatMul Logic
            # Result C = A @ B
            rows = info_a['dims'][0]
            common = info_a['dims'][1]
            cols = info_b['dims'][1]
            
            if common != info_b['dims'][0]:
                raise ValueError(f"Matrix dimension mismatch: {info_a['dims']} @ {info_b['dims']}")
                
            # Allocate Result C
            size = rows * cols
            addr_c = self.dat_ptr
            # self.dat_ptr += size # allocated temp? yes.
            # actually better to not leak temps forever.
            # but for v0.1, linear allocation is fine.
            self.dat_ptr += size
            
            # Emit code
            # We have AdrrA, AddrB, AddrC.
            # But we need R1 to hold AddrC at the end.
            
            # Emit Nested Loops for MatMul
            # We need to compute C[i,j] += A[i,k] * B[k,j]
            # Rows=rows, Cols=cols, Common=common
            # Registers:
            # R1: Result Accumulator
            # R2: Temp
            # R3: i (Row C)
            # R4: j (Col C)
            # R5: k (Common)
            # R6: Addr A (Base)
            # R7: Addr B (Base)
            # R8: Addr C (Base)
            
            # Save Registers? (Compiler v0.1: No register allocator yet, assuming free use of R1-R10 inside expression)
            # Warning: If we are deep in expression, we might clobber stack ops.
            # But MatMult is statement-level usually.
            
            # Labels
            lbl_i_start = self.new_label("mm_i")
            lbl_j_start = self.new_label("mm_j")
            lbl_k_start = self.new_label("mm_k")
            lbl_i_end = self.new_label("mm_i_end")
            lbl_j_end = self.new_label("mm_j_end")
            lbl_k_end = self.new_label("mm_k_end")
            
            self.emit(f"; --- MatMul Loop {name_a} [{rows}x{common}] @ {name_b} [{common}x{cols}] ---")
            
            # Registers:
            # R3: i (Row)
            # R4: j (Col)
            # R5: k (Common)
            # R10: Accumulator
            
            # i = 0
            self.emit("LDI.W R3, 0")
            self.emit(f"{lbl_i_start}:")
            self.emit(f"LDI.W R1, {rows}")
            self.emit("CMP.W R3, R1")
            self.emit(f"BEQ {lbl_i_end}")
            
            # j = 0
            self.emit("LDI.W R4, 0")
            self.emit(f"{lbl_j_start}:")
            self.emit(f"LDI.W R1, {cols}")
            self.emit("CMP.W R4, R1")
            self.emit(f"BEQ {lbl_j_end}")
            
            # Accumulator R10 = 0
            self.emit("LDI.W R10, 0")
            
            # k = 0
            self.emit("LDI.W R5, 0")
            self.emit(f"{lbl_k_start}:")
            self.emit(f"LDI.W R1, {common}")
            self.emit("CMP.W R5, R1")
            self.emit(f"BEQ {lbl_k_end}")
            
            # Body: R10 += A[i,k] * B[k,j]
            
            # Load A[i,k] -> R1
            # Offset = i * Common + k
            self.emit("MOV.W R2, R3") # i
            self.emit(f"LDI.W R1, {common}")
            self.emit("MUL.W R2, R2, R1")
            self.emit("ADD.W R2, R2, R5") # + k
            self.emit(f"LDI.W R6, {info_a['addr']}")
            self.emit("ADD.W R6, R6, R2")
            self.emit("LD.W R1, [R6, 0]") # Val A
            
            # Load B[k,j] -> R2
            # Offset = k * Cols + j
            self.emit("MOV.W R9, R5") # k (Using R9 temp to be safe)
            self.emit(f"LDI.W R1, {cols}")
            self.emit("MUL.W R9, R9, R1")
            self.emit("ADD.W R9, R9, R4") # + j
            self.emit(f"LDI.W R7, {info_b['addr']}")
            self.emit("ADD.W R7, R7, R9")
            self.emit("LD.W R2, [R7, 0]") # Val B
            
            # Multiply
            self.emit("MUL.W R1, R1, R2")
            
            # Accumulate
            self.emit("ADD.W R10, R10, R1")
            
            # k++
            self.emit("LDI.W R1, 1")
            self.emit("ADD.W R5, R5, R1")
            self.emit(f"JMP {lbl_k_start}")
            self.emit(f"{lbl_k_end}:")
            
            # Store C[i,j] = R10
            # Offset = i * Cols + j
            self.emit("MOV.W R9, R3") # i
            self.emit(f"LDI.W R1, {cols}")
            self.emit("MUL.W R9, R9, R1")
            self.emit("ADD.W R9, R9, R4") # + j
            self.emit(f"LDI.W R8, {addr_c}")
            self.emit("ADD.W R8, R8, R9")
            self.emit("ST.W R10, [R8, 0]")
            
            # j++
            self.emit("LDI.W R1, 1")
            self.emit("ADD.W R4, R4, R1")
            self.emit(f"JMP {lbl_j_start}")
            self.emit(f"{lbl_j_end}:")
            
            # i++
            self.emit("LDI.W R1, 1")
            self.emit("ADD.W R3, R3, R1")
            self.emit(f"JMP {lbl_i_start}")
            self.emit(f"{lbl_i_end}:")
            
            # Result C is at addr_c. Ensure visit_Assign logic knows this.
            # visit_Assign expects R1 to have Address of C.
            self.emit(f"LDI.W R1, {addr_c}")
            return

        if isinstance(node.op, (ast.Add, ast.Sub)) and isinstance(node.left, ast.Name) and isinstance(node.right, ast.Name):
            # Check for Matrix Add/Sub
            name_a = node.left.id
            name_b = node.right.id
            
            if name_a in self.scope and name_b in self.scope:
                info_a = self.scope[name_a]
                info_b = self.scope[name_b]
                
                if info_a['type'] == 'matrix' and info_b['type'] == 'matrix':
                    if info_a['dims'] != info_b['dims']:
                         raise ValueError(f"Matrix dimension mismatch for Op: {info_a['dims']} vs {info_b['dims']}")
                    
                    rows, cols = info_a['dims']
                    size = rows * cols
                    
                    # Allocate Result C
                    addr_c = self.dat_ptr
                    self.dat_ptr += size
                    
                    self.emit(f"; --- Matrix Op {name_a} {node.op.__class__.__name__} {name_b} -> .DAT {addr_c} ---")
                    
                    # Loop over all elements (Linear)
                    lbl_loop = self.new_label("mat_op_loop")
                    lbl_end = self.new_label("mat_op_end")
                    
                    # R3 = Index (0 to size)
                    self.emit("LDI.W R3, 0")
                    
                    self.emit(f"{lbl_loop}:")
                    self.emit(f"LDI.W R1, {size}")
                    self.emit("CMP.W R3, R1")
                    self.emit(f"BEQ {lbl_end}")
                    
                    # Load A[i]
                    self.emit(f"LDI.W R6, {info_a['addr']}")
                    self.emit("ADD.W R6, R6, R3")
                    self.emit("LD.W R1, [R6, 0]")
                    
                    # Load B[i]
                    self.emit(f"LDI.W R7, {info_b['addr']}")
                    self.emit("ADD.W R7, R7, R3")
                    self.emit("LD.W R2, [R7, 0]")
                    
                    # Compute
                    if isinstance(node.op, ast.Add):
                        self.emit("ADD.W R1, R1, R2")
                    elif isinstance(node.op, ast.Sub):
                        self.emit("SUB.W R1, R1, R2")
                        
                    # Store C[i]
                    self.emit(f"LDI.W R8, {addr_c}")
                    self.emit("ADD.W R8, R8, R3")
                    self.emit("ST.W R1, [R8, 0]")
                    
                    # Increment Index
                    self.emit("LDI.W R1, 1")
                    self.emit("ADD.W R3, R3, R1")
                    self.emit(f"JMP {lbl_loop}")
                    
                    self.emit(f"{lbl_end}:")
                    
                    # Result C Addr in R1
                    self.emit(f"LDI.W R1, {addr_c}")
                    return

        # Scalar BinOp Logic
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R1, [SP, 0]")
        
        self.visit(node.right)
        self.emit("MOV.W R2, R1") # Right -> R2
        self.emit("LD.W R1, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")
        
        # BinOp Result in R1
        if isinstance(node.op, ast.Add):
            self.emit("ADD.W R1, R1, R2")
        elif isinstance(node.op, ast.Sub):
            self.emit("SUB.W R1, R1, R2")
        elif isinstance(node.op, ast.Mult):
            self.emit("MUL.W R1, R1, R2")
        elif isinstance(node.op, ast.Div):
            self.emit("DIV.W R1, R1, R2")
        elif isinstance(node.op, ast.Mod):
             self.emit("MOD.W R1, R1, R2")

    def visit_UnaryOp(self, node):
        self.visit(node.operand) # R1 = Operand
        
        if isinstance(node.op, ast.USub):
            self.emit("LDI.W R2, -1")
            self.emit("MUL.W R1, R1, R2")
        elif isinstance(node.op, ast.UAdd):
            pass # +x is x
        elif isinstance(node.op, ast.Not):
            # Logical Not (0 -> 1, else -> 0)
            self.emit("CMP.W R1, 0")
            lbl_true = self.new_label("not_true")
            lbl_end = self.new_label("not_end")
            self.emit(f"BEQ {lbl_true}")
            self.emit("LDI.W R1, 0")
            self.emit(f"JMP {lbl_end}")
            self.emit(f"{lbl_true}:")
            self.emit("LDI.W R1, 1")
            self.emit(f"{lbl_end}:")
            
    def visit_Constant(self, node):
        if isinstance(node.value, int):
            self.emit(f"LDI.W R1, {node.value}")
            
    def visit_Assign(self, node):
        if len(node.targets) != 1:
            raise NotImplementedError("Only single assignment supported")

        target = node.targets[0]
        
        # Case 1: Assignment to Variable (Name)
        if isinstance(target, ast.Name):
            var_name = target.id

            # Compile value (Result in R1)
            self.visit(node.value)
            
            # Check if we are assigning to an existing variable
            if var_name in self.scope:
                var_info = self.scope[var_name]
                if var_info['type'] == 'int':
                    offset = var_info['offset']
                    self.emit(f"ST.W R1, [FP, {offset}] ; {var_name} = R1")
                elif var_info['type'] == 'matrix':
                    # Matrix Assignment (Copy)
                    dest_addr = var_info['addr']
                    rows, cols = var_info['dims']
                    size = rows * cols
                    
                    self.emit(f"; --- Copy Matrix to {var_name} ({size} words) ---")
                    # R1 has Source Address
                    # R2 = Destination Address
                    self.emit(f"LDI.W R2, {dest_addr}")
                    
                     # Loop Check
                    # R3 = Index
                    self.emit("LDI.W R3, 0")
                    lbl_copy = self.new_label(f"copy_{var_name}")
                    lbl_end = self.new_label(f"copy_{var_name}_end")
                    
                    self.emit(f"{lbl_copy}:")
                    self.emit(f"LDI.W R4, {size}")
                    self.emit("CMP.W R3, R4")
                    self.emit(f"BEQ {lbl_end}")
                    
                    # Cpy
                    self.emit("LD.W R4, [R1, 0]") # Load from Source
                    self.emit("ST.W R4, [R2, 0]") # Store to Dest
                    
                    # Inc
                    self.emit("LDI.W R4, 1")
                    self.emit("ADD.W R1, R1, R4") # Inc Src Ptr
                    self.emit("ADD.W R2, R2, R4") # Inc Dest Ptr
                    self.emit("ADD.W R3, R3, R4") # Inc Index
                    self.emit(f"JMP {lbl_copy}")
                    self.emit(f"{lbl_end}:")
                    
            else:
                 # Implicit int declaration
                self.stack_pointer -= 1
                self.scope[var_name] = {'offset': self.stack_pointer, 'type': 'int'}
                self.emit(f"ADD.W SP, SP, -1 ; Alloc {var_name}")
                offset = self.stack_pointer
                self.emit(f"ST.W R1, [FP, {offset}] ; {var_name} = R1")

        # Case 2: Assignment to Subscript (M[i,j] = val)
        elif isinstance(target, ast.Subscript):
             # 1. Evaluate Value -> R1
             self.visit(node.value)
             
             # 2. Push Value to Stack (Preserve across address calculation)
             self.emit("ADD.W SP, SP, -1")
             self.emit("ST.W R1, [SP, 0]")
             
             # 3. Visit Target (Calculates Address -> R6)
             # visit_Subscript will see ctx=Store and ONLY return address in R6
             self.visit(target)
             
             # 4. Pop Value -> R1
             # Value is at [SP, 0] if we popped indices?
             # Wait, visit_Subscript (ctx=Store) calculates address R6. 
             # It assumes indices are handled.
             # In visit_Subscript:
             #  - Pushes Row (SP-1)
             #  - Pushes Col (SP-1) -> Pops Row -> Ops -> Address R6
             # So indices are popped. Stack is back to where "Value" is at [SP, 0].
             # BUT:
             # In generated code:
             # 114: ST R1, [SP, 0] (Value 99)
             # 121..137: visit_Subscript handles indices and address calc.
             # Inside visit_Subscript:
             #   124: ST R1, [SP] (Row 1)
             #   .. logic ..
             #   127: ST R1, [SP] (Col 0) -> R3
             #   128: ADD SP, 1
             # The stack should be balanced by visit_Subscript.
             # Let's check visit_Subscript.
             # It pops Row (line 597: ADD SP, 1).
             # It does NOT push Col to stack?
             # Line 593: self.emit("MOV.W R4, R1") -> Col in R4.
             # So visit_Subscript is stack-neutral regarding its own pushes/pops?
             # Yes: Push Row, Pop Row.
             # So when visit_Subscript returns, Value is at [SP, 0].
             #
             # WAIT. Line 135 in HASM: LD.W R1, [SP, 0]
             # Line 136: ADD SP, SP, 1
             # This loads `1`??
             # Where did `1` come from? 
             # Line 122: LDI R1, 1
             # Line 124: ST R1, [SP, 0]  (This is Row Index!)
             # visit_Subscript MUST have left something on stack or I misread.
             #
             # Re-reading Subscript Logic in HASM (122-134):
             # 122: LDI R1, 1
             # 123: ADD SP, -1
             # 124: ST R1, [SP] (Push Row)
             # 125: LDI R1, 0 (Evaluate Col)
             # 126: MOV R4, R1
             # 127: LD R3, [SP] (Pop Row)
             # 128: ADD SP, 1
             # ... Calc R6 ...
             #
             # So visit_Subscript IS stack neutral.
             # So why is `1` at [SP, 0] at line 135?
             # Ah, `LD.W R1, [SP, 0]` reads from current SP.
             # At line 114, we pushed 99. SP indicates 99.
             # At line 124, we pushed 1. SP indicates 1.
             # At line 128, we popped 1. SP indicates 99.
             # So `LD R1, [SP, 0]` at 135 *should* read 99.
             #
             # UNLESS `visit_Subscript` logic I see in file is different from what executed?
             # generated hasm lines 122-124:
             # 122: LDI R1, 1
             # 123: ADD SP, SP, -1
             # 124: ST R1, [SP, 0]
             #
             # Line 127: LD R3, [SP, 0]
             # Line 128: ADD SP, SP, 1
             #
             # It looks correct.
             #
             # Maybe the `1` came from `R1` not being clobbered?
             # Line 135: LD R1, [SP, 0]
             # If SP points to 99, it loads 99.
             #
             # ERROR FOUND:
             # Line 124: ST R1, [SP, 0] (Push 1).
             # ...
             # Line 127: LD R3, [SP, 0] (Pop 1).
             # Line 128: ADD SP, SP, 1.
             # SP now points to 99.
             #
             # Logic seems fine. Why is output missing?
             # Maybe `print` is never called?
             # The hasm shows `CALL __print_int` only TWICE.
             # Line 59 and Line 100.
             # The source `test_matrix_access.py` has THREE prints.
             # 1. print(z)
             # 2. print(val)
             # 3. print(A[1, 0])
             #
             # The compiler generated code for `print(A[1, 0])` (lines 138+) says:
             # "; PRINT statement (Complex/Unsupported args ignored in V0.2)"
             #
             # CHECK `visit_Expr` in `helix_py_compiler.py`:
             # It only supports `print(const)`, `print(var)`, `print(-const)`.
             # It does NOT support `print(A[i, j])` (Subscript).
             # That is why the third output is missing!
             #
             # Fix: Implement `print(Subscript)` in `visit_Expr`.
             
             # I will skip the edit to `visit_Assign` as it seems correct (stack neutral).
             # Instead I will modify `visit_Expr` to support printing subscripts.
             self.emit("LD.W R1, [SP, 0]")
             self.emit("ADD.W SP, SP, 1")
             
             # 5. Store Value to Address
             self.emit("ST.W R1, [R6, 0]")
             
        else:
            raise NotImplementedError("Only assignment to variable or subscript supported")

    def visit_Name(self, node):
        var_name = node.id
        if var_name in self.scope:
            var_info = self.scope[var_name]
            if var_info['type'] == 'int':
                offset = var_info['offset']
                if isinstance(node.ctx, ast.Load):
                    self.emit(f"LD.W R1, [FP, {offset}] ; Load {var_name}")
            elif var_info['type'] == 'matrix':
                 # Load Address of Matrix
                 addr = var_info['addr']
                 self.emit(f"LDI.W R1, {addr}")
            else:
                 raise NotImplementedError(f"Load not implemented for type {var_info['type']}")
        else:
             raise ValueError(f"Undefined variable: {var_name}")

    def visit_Compare(self, node):
        # Only support simple: Left Op Right
        if len(node.ops) != 1:
            raise NotImplementedError("Only single comparison supported")

        self.visit(node.left)
        # self.emit("PUSH.W R1")
        self.emit("ADD.W SP, SP, -1")
        self.emit("ST.W R1, [SP, 0]")
        
        self.visit(node.comparators[0])
        self.emit("MOV.W R2, R1") # Right -> R2
        # self.emit("POP.W R1")     # Left -> R1
        self.emit("LD.W R1, [SP, 0]")
        self.emit("ADD.W SP, SP, 1")

        self.emit("CMP.W R1, R2")
        # Result of comparison is usually boolean 1/0, but flow control uses flags.
        # If this is part of an IF, we just need flags set.
        # But if it's value assignment (x = a < b), we need 1/0.
        # Complexity: AST doesn't know context.
        # Simplification: Assume Compare is ALWAYS used in If/While for now (Phase 1).
        # Or: Emit 1/0 to R1?
        # Let's emit 1/0 to R1 for generality, then IF can check R1 != 0.
        # Wait, efficient branching wants flags.
        # Compromise: Comparison returns 1/0 in R1.
        
        lbl_true = self.new_label("cmp_true")
        lbl_end = self.new_label("cmp_end")
        
        op = node.ops[0]
        if isinstance(op, ast.Eq):    self.emit(f"BEQ {lbl_true}")
        elif isinstance(op, ast.NotEq): self.emit(f"BNE {lbl_true}")
        elif isinstance(op, ast.Lt):    self.emit(f"BLT {lbl_true}")
        elif isinstance(op, ast.Gt):    self.emit(f"BGT {lbl_true}")
        elif isinstance(op, ast.LtE):   raise NotImplementedError("LTE not supported")
        elif isinstance(op, ast.GtE):   raise NotImplementedError("GTE not supported")
        
        self.emit("LDI.W R1, 0") # False
        self.emit(f"JMP {lbl_end}")
        self.emit(f"{lbl_true}:")
        self.emit("LDI.W R1, 1") # True
        self.emit(f"{lbl_end}:")

    def visit_If(self, node):
        # Check for if __name__ == "__main__": pattern
        # This is strictly for skipping the entry point check, as we call main() automatically.
        if isinstance(node.test, ast.Compare):
            if isinstance(node.test.left, ast.Name) and node.test.left.id == "__name__":
                 self.emit("; Skipped 'if __name__ == \"__main__\":' block (Entry point handled by runtime)")
                 return

        lbl_else = self.new_label("else")
        lbl_end = self.new_label("if_end")

        # Test condition
        self.visit(node.test) # R1 has 0 or 1
        
        # In standard C/Python, "if (x)" checks x != 0.
        self.emit("CMP.W R1, 0")
        self.emit(f"BEQ {lbl_else}") # Jump if False (0)

        # Body
        for stmt in node.body:
            self.visit(stmt)
        self.emit(f"JMP {lbl_end}")

        self.emit(f"{lbl_else}:")
        if node.orelse:
            for stmt in node.orelse:
                self.visit(stmt)
        
        self.emit(f"{lbl_end}:")

    def visit_While(self, node):
        lbl_start = self.new_label("while_start")
        lbl_end = self.new_label("while_end")

        self.emit(f"{lbl_start}:")
        
        # Test
        self.visit(node.test)
        self.emit("CMP.W R1, 0")
        self.emit(f"BEQ {lbl_end}")

        # Body
        for stmt in node.body:
            self.visit(stmt)
            
        self.emit(f"JMP {lbl_start}")
        self.emit(f"{lbl_end}:")

        
    def visit_Try(self, node):
        self.emit("; Try Block (handlers ignored in v0.1)")
        for stmt in node.body:
            self.visit(stmt)
        # We process 'orelse' if we want to follow success path?
        # Usually 'orelse' runs if no exception. 
        # Since we ignore handlers and assume no exceptions in ASM v0.1 (except traps),
        # we generally flow through.
        if node.orelse:
            for stmt in node.orelse:
                self.visit(stmt)
        if node.finalbody:
            for stmt in node.finalbody:
                self.visit(stmt)

    def visit_Call(self, node):
        func_name = node.func.id
        
        # 1. Push Args (Left-to-Right)
        # Our ABI: Args are pushed onto the stack.
        # Arg0 is pushed first, so it is at deeper stack address.
        # ArgN is pushed last, so it is at top of stack (lower address).
        
        args = node.args
        num_args = len(args)
        
        for i, arg in enumerate(args):
            self.visit(arg) # Result in R1
            # Push R1
            self.emit("ADD.W SP, SP, -1")
            self.emit("ST.W R1, [SP, 0]")
            
        # 2. Call
        # Arguments are now on stack.
        self.emit(f"CALL {func_name}")
        
        # 3. Clean up Stack (Pop Args)
        # We just move SP up by num_args
        if num_args > 0:
            self.emit(f"ADD.W SP, SP, {num_args} ; Clean up args")
            
        # Result is in R1.

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Helix Python Compiler")
    parser.add_argument("input", help="Input Python file")
    args = parser.parse_args()
    
    with open(args.input, "r") as f:
        src = f.read()
        
    compiler = HelixCompiler()
    asm = compiler.compile(src)
    print(asm)
